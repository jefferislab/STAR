#'Get Backward Recurrence Times from Data Frames Generated by mkGLMdf
#'
#'Spike trains discharge models for single neurons are rarely renewal. They
#'require more information than just the elapsed time since the last spike.
#'Function \code{brt4df} generates this additional information from a data
#'frame obtained by \code{mkGLMdf}.
#'
#'If the spike required to evaluate the elapsed time is not contained in
#'\code{df} then \code{NA} will be the reported elapsed time.
#'
#'@param df A \code{\link{data.frame}} generated by \code{\link{mkGLMdf}} and
#'containing the events of a single neuron.
#'@param varName The name of one of the variables of \code{df}. It should be
#'one of the "elapsed time" variables, like, \code{lN.x}, where \code{x} stands
#'for a neuron number.
#'@param max.order How many events should looked for in the past?
#'@param colNames Names of the columns of the returned
#'\code{\link{data.frame}}. If missing default names are provided.
#'@param auto A logical. Does \code{varName} refer to the elapsed times since
#'the last spike of the neuron whose spikes are recorded in the \code{event}
#'variable (\code{TRUE}) or not (\code{FALSE})?
#'@param normalise A \code{\link{function}} applied to the extracted data in
#'order to normalise them. If missing ,nothing is done and the extracted data
#'are left unchanged.
#'@return A \code{\link{data.frame}} is returned with as many variable as
#'\code{max.order} and as many rows as \code{df}.
#'@author Christophe Pouzat \email{christophe.pouzat@@gmail.com}
#'@seealso \code{\link{mkGLMdf}}, \code{\link{data.frame}}, \code{\link{glm}},
#'\code{\link{mgcv}}
#'@references Kass, Robert E. and Ventura, Val\'erie (2001) A spike-train
#'probability model \emph{Neural Comput.} \bold{13}: 1713--1720.
#'
#'Truccolo, W., Eden, U. T., Fellows, M. R., Donoghue, J. P. and Brown, E. N.
#'(2005) A Point Process Framework for Relating Neural Spiking Activity to
#'Spiking History, Neural Ensemble and Extrinsic Covariate Effects \emph{J
#'Neurophysiol} \bold{93}: 1074--1089.
#'\url{http://jn.physiology.org/cgi/content/abstract/93/2/1074}
#'@keywords models
#'@examples
#'
#'\dontrun{
#'## Let us consider neuron 1 of the CAL2S data set
#'data(CAL2S)
#'CAL2S <- lapply(CAL2S,as.spikeTrain)
#'CAL2S[["neuron 1"]]
#'renewalTestPlot(CAL2S[["neuron 1"]])
#'summary(CAL2S[["neuron 1"]])
#'## Make a data frame with a 4 ms time resolution
#'cal2Sdf <- mkGLMdf(CAL2S,0.004,0,60)
#'## keep the part relative to neuron 1
#'n1.cal2sDF <- cal2Sdf[cal2Sdf$neuron=="1",]
#'## remove unnecessary data
#'rm(cal2Sdf)
#'## Extract the elapsed time since the second to last and
#'## third to last for neuron 1. Normalise the result. 
#'n1.cal2sDF[c("rlN.1","rsN.1","rtN.1")] <- brt4df(n1.cal2sDF,"lN.1",2,c("rlN.1","rsN.1","rtN.1"))
#'## load mgcv library
#'library(mgcv)
#'## fit a model with a tensorial product involving the last
#'## three spikes and using a cubic spline basis for the last two
#'n1S.fitA <- gam(event ~ te(rlN.1,rsN.1,bs="cr") + rtN.1,data=n1.cal2sDF,family=binomial(link="logit"))
#'summary(n1S.fitA)
#'## plot the result in 2 different ways
#'plot(n1S.fitA)
#'vis.gam(n1S.fitA,phi=20,theta=45)
#'
#'}
#'
brt4df <- function(df,
                   varName,
                   max.order=1,
                   colNames,
                   auto=TRUE,
                   normalise=function(x) as.numeric(scale(log(x)))) {

  ## check that df is a data.frame
  if (!inherits(df,"data.frame"))
    stop("Argument df should be a data frame")

  ## check that varName is a df variable name
  if (!(varName %in% names(df)))
    stop(paste(varName,"should be a variable name of data frame df"))

  ## make sure that max.order makes sense
  max.order <- as.integer(max.order)
  if (max.order < 1) max.order <- as.integer(1)
  
  n <- dim(df)[1]
  if (auto) {
    eventIdx <- (1:n)[df$event==1]
  } else {
    eventIdx <- (1:n)[df[[varName]]==0]
    eventIdx <- eventIdx[!is.na(eventIdx)][-1]
  }
  
  lastOne <- eventIdx[length(eventIdx)]
  st <- df[,varName]
  rm(df)
  result <- matrix(integer(n*max.order),
                   nrow=n,
                   ncol=max.order)
  
  for (ordIdx in 1:max.order) {

    result[1:eventIdx[ordIdx],ordIdx] <- NA
    
    if (lastOne != n) {
      if (auto) offset <- st[lastOne]
      else offset <- st[lastOne-1]+1
      result[(lastOne+1):n,ordIdx] <- offset+seq(n-lastOne)
    }
    
    for (i in seq(along=eventIdx)[-(1:ordIdx)]) {
      mySeq <- (eventIdx[i-1]+1):eventIdx[i]
      if (auto) {
        if (ordIdx == 1) offset <- st[eventIdx[i-1]]
        else offset <- result[eventIdx[i-1],ordIdx-1]
      } else {
        if (ordIdx == 1) offset <- st[eventIdx[i-1]-1] + 1
        else offset <- result[eventIdx[i-1]-1,ordIdx-1] + 1
      }
      result[mySeq,ordIdx] <-  offset + seq(along=mySeq)
    } ## End of the loop on i

  } ## End of for loop on ordIdx
  
  if (inherits(normalise,"function")) {
    result <- apply(result,2,normalise)
    result <- cbind(normalise(st),result)
    if (missing(colNames)) colNames <- c(paste("r",varName,sep=""),
                                         paste("r",varName,".",(1:max.order)+1,sep=""))
    colnames(result) <- colNames
  } else {
    if (missing(colNames)) colNames <- paste(varName,".",(1:max.order)+1,sep="")
    colnames(result) <- colNames
  }
  
  as.data.frame(result)

}
