#'Construct and Plot Time-Dependent Cross-correlation Diagram
#'
#'\code{lockedTrain} constructs and \code{plot.lockedTrain} (and
#'\code{print.lockedTrain}) plot what van Stokkum et al (1986) call a
#'time-dependent cross-correlation diagram. The lags between spikes of a test
#'and a reference trains are plotted against the time of occurrence or the rank
#'of the reference train spikes.
#'
#'The time-dependent cross-correlation diagram is described in van Stokkum et
#'al (1986) and is also used by Brillinger (1992) Fig. 4. For each spike of
#'\code{stRef} neighboring spikes of \code{stTest} are selected within a window
#'defined by \code{laglim}. The lag between these \code{stTest} spikes and the
#'ones of \code{stRef} are displayed (that is, the times of the \code{stRef}
#'spikes is subtracted from the times of the neighboring spikes in
#'\code{stTest}).
#'
#'If \code{repeatedTrain}s are given for \code{stRef} and \code{stTest} they
#'must have the same number of components and are interpreted as coming from
#'repetitions of the same stimulation, the spike times of the different trains
#'of \code{stRef} are therefore reordered.
#'
#'The ordinate on the plot generated by \code{plot.lockedTrain} can be in term
#'of real time or in term of \code{stRef} spike indexes.
#'
#'If \code{stimTimeCourse} is specified a box corresponding to the stimulus
#'presentation is drawn in the background.
#'
#'@aliases lockedTrain plot.lockedTrain print.lockedTrain
#'@param stRef a \code{spikeTrain} or a \code{repeatedTrain} object.
#'@param stTest a \code{spikeTrain} or a \code{repeatedTrain} object. If
#'\code{missing(stTest)} is \code{TRUE} then \code{stRef} is used.
#'@param x a \code{lockedTrain} object.
#'@param laglim a two elements vector, the time window (in s) in which spikes
#'in \code{stTest} around spikes in \code{stRef} are looked for. Default value
#'are supplied when the argument is missing (+/- 3 times the sd of the
#'inter-spike intervals of \code{stRef}).
#'@param acquisitionWindow a 2 elements vector specifying the begining and the
#'end of the acquisition. If \code{missing} values are obtained using the
#'\code{\link{floor}} of the smallest spike time and the \code{\link{ceiling}}
#'of the largest one.
#'@param keepTime a logical, if \code{TRUE} the ordinate is shown in s,
#'otherwise (default) the spike index is shown.
#'@param stimTimeCourse \code{NULL} (default) or a two elements vector
#'specifying the time boundaries (in s) of a stimulus presentation.
#'@param colStim the background color used for the stimulus.
#'@param xlim a numeric (default value supplied). See \code{\link{plot}}.
#'@param pch data symbol used for the spikes. See \code{\link{plot}}.
#'@param xlab a character (default value supplied). See \code{\link{plot}}.
#'@param ylab a character (default value supplied). See \code{\link{plot}}.
#'@param main a character (default value supplied). See \code{\link{plot}}.
#'@param \dots see \code{\link{plot}} or \code{\link{print}}.
#'@return \code{lockedTrain} returns a LIST of class \code{lockedTrain} with
#'the following components:
#'
#'\code{plot.lockedTrain} and \code{print.lockedTrain} are used for their side
#'effects: a plot is generated. \code{print.lockedTrain} calls
#'\code{plot.lockedTrain}.
#'@returnItem shiftedT a list of lists. Each sublist has three components:
#'\code{refTime}, the time of the reference spike; \code{repIdx}, the index of
#'the stimulus repeat to which the reference spike belongs; \code{crossTime}, a
#'vector of shifted times of the test neurons. These times are shifted because
#'they are expressed with respect to the reference spike time.
#'@returnItem nbRefSpikes the total number of reference spikes used.
#'@returnItem nbTestSpikes the total number of test spikes occurring during the
#'same observation period.
#'@returnItem laglim the value of \code{laglim} used.
#'@returnItem acquisitionWindow the value of the \code{acquisitionWindow} used.
#'@returnItem obsTime the total observation time used (in s).
#'@returnItem call the matched call.
#'@note \code{plot.lockedTrain} displays essentially the "raw data" from which
#'a cross-intensity histogram is built.
#'@author Christophe Pouzat \email{christophe.pouzat@@gmail.com}
#'@seealso \code{\link{as.spikeTrain}}, \code{\link{as.repeatedTrain}},
#'\code{\link{raster}}
#'@references van Stokkum, I. H., Johannesma, P. I. and Eggermont, J. J. (1986)
#'Representation of time-dependent correlation and recurrence time functions. A
#'new method to analyse non-stationary point processes. \emph{Biol Cybern}
#'\bold{55}: 17--24.
#'
#'Brillinger, David R. (1992) Nerve Cell Spike Train Data Analysis: A
#'Progression of Technique. \emph{JASA} \bold{87}: 260--271.
#'@keywords ts survival
#'@examples
#'
#'\dontrun{
#'## load spontaneous data of 4 putative projection neurons
#'## simultaneously recorded from the cockroach (Periplaneta
#'## americana) antennal lobe
#'data(CAL1S)
#'## convert data into spikeTrain objects
#'CAL1S <- lapply(CAL1S,as.spikeTrain)
#'## look at the individual trains
#'## first the "raw" data
#'CAL1S[["neuron 1"]]
#'## contruct the lockedTrain of each neuron with itself and look at
#'## it using a lag of +/- 25 ms
#'lockedTrain(CAL1S[["neuron 1"]],laglim=c(-1,1)*0.025)
#'lockedTrain(CAL1S[["neuron 2"]],laglim=c(-1,1)*0.025)
#'lockedTrain(CAL1S[["neuron 3"]],laglim=c(-1,1)*0.025)
#'lockedTrain(CAL1S[["neuron 4"]],laglim=c(-1,1)*0.025)
#'
#'## Look at the Vanillin responses
#'## Get the data
#'data(CAL1V)
#'## convert them into repeatedTrain objects
#'## The stimulus command is on between 4.49 s and 4.99s
#'CAL1V <- lapply(CAL1V,as.repeatedTrain)
#'## look at the individual raster plots
#'plot(CAL1V[["neuron 1"]],stimTimeCourse=c(4.49,4.99),main="N1")
#'plot(CAL1V[["neuron 2"]],stimTimeCourse=c(4.49,4.99),main="N2")
#'plot(CAL1V[["neuron 3"]],stimTimeCourse=c(4.49,4.99),main="N3")
#'plot(CAL1V[["neuron 4"]],stimTimeCourse=c(4.49,4.99),main="N4")
#'## construct the locked train for the 3 pairs with neuron 1 as a
#'## reference
#'plot(lockedTrain(CAL1V[["neuron 1"]],CAL1V[["neuron 3"]],
#'     laglim=0.01*c(-1,1)),stimTimeCourse=c(4.49,4.99),pch="*")
#'plot(lockedTrain(CAL1V[["neuron 1"]],CAL1V[["neuron 2"]],
#'     laglim=0.01*c(-1,1)),stimTimeCourse=c(4.49,4.99),pch="*")
#'plot(lockedTrain(CAL1V[["neuron 1"]],CAL1V[["neuron 4"]],
#'     laglim=0.01*c(-1,1)),stimTimeCourse=c(4.49,4.99),pch="*")
#'}
#'
lockedTrain <- function(stRef,
                        stTest,
                        laglim,
                        acquisitionWindow
                        ) {

  if (missing(stTest)) {
    stTest <- stRef
    nameTest <- deparse(substitute(stRef))
  } else {
    nameTest <- deparse(substitute(stTest))
  }
  nameRef <- deparse(substitute(stRef))
  

  ## stRef and stTest should be spikeTrain or repeatedTrain objects
  if (!is.spikeTrain(stRef) && !is.repeatedTrain(stRef))
    stop(paste(nameRef,
               "should be a spikeTrain or a repeatedTrain object.")
         )
  if (!is.spikeTrain(stTest) && !is.repeatedTrain(stTest))
    stop(paste(nameTest,
               "should be a spikeTrain or a repeatedTrain object.")
         )

  if (is.spikeTrain(stRef)) {
    nbRepeat <- 1
    stRef <- as.repeatedTrain(list(stRef))
    if (!is.spikeTrain(stTest)) {
      stop(paste(nameRef,"and",nameTest,
               "should be spikeTrain objects.")
         )
    } else {
      stTest <- as.repeatedTrain(list(stTest))
    }
  } else {
    nbRepeat <- length(stRef)
    if (nbRepeat != length(stTest))
      stop(paste(nameRef,"and",nameTest,
                 "should be repeatedTrain objects with identical number of repeats.")
           )
  } 
  
  isi <- function(l) unlist(lapply(l,diff))
  if (missing(laglim)) laglim <- c(-3,3)*sd(isi(stRef))

  if (missing(acquisitionWindow)) {
    acquisitionWindow <- numeric(2)
    acquisitionWindow[1] <- floor(min(c(unlist(stRef),unlist(stTest))))
    acquisitionWindow[2] <- ceiling(max(c(unlist(stRef),unlist(stTest))))
  }
  
  lagList <- function(ref,test,laglim) {
    totalRef <- 0
    totalTest <- 0
    result <- lapply(1:nbRepeat,
                     function(repIdx)
                     {
                       spikeTrainRef <- ref[[repIdx]]
                       goodRef <- ((spikeTrainRef-acquisitionWindow[1]) >= -laglim[1]) &
                       ((acquisitionWindow[2]-spikeTrainRef) >= laglim[2])
                       spikeTrainRef <- spikeTrainRef[goodRef]
                       spikeTrainTest <- test[[repIdx]]
                       ## goodTest <- ((spikeTrainTest-acquisitionWindow[1]) >= -laglim[1]) &
                       ## ((acquisitionWindow[2]-spikeTrainTest) >= laglim[2])
                       nbRefSpikes <- length(spikeTrainRef)
                       totalRef <<- totalRef + nbRefSpikes
                       ## totalTest <<- totalTest + sum(goodTest)
                       totalTest <<- totalTest + length(spikeTrainTest)
                       repResult <- lapply(1:nbRefSpikes,
                                           function(idx) {
                                             newZero <- spikeTrainRef[idx]
                                             shiftedTest <- spikeTrainTest-newZero
                                             goodTest <- laglim[1] <= shiftedTest &
                                             shiftedTest <= laglim[2]
                                             shiftedTest <- shiftedTest[goodTest]
                                             return(shiftedTest)
                                           }
                                           )
                       list(refTime=spikeTrainRef,
                            repIdx=repIdx,
                            crossTime=repResult)
                     }
                     )
    output <- vector("list",totalRef)
    gblIdx <- 1
    repIdx <- 1
    for (idx in 1:nbRepeat) {
      nbRefSpikes <- length(result[[idx]]$refTime)
      for (spikeIdx in 1:nbRefSpikes) {
        output[[gblIdx]] <- list(refTime=result[[idx]]$refTime[spikeIdx],
                                 repIdx=result[[idx]]$repIdx,
                                 crossTime=result[[idx]]$crossTime[[spikeIdx]]
                                 )
        gblIdx <- gblIdx+1
      } ## End of for loop on spikeIdx
    } ## End of for loop on idx
    output <- c(output,list(nbTestSpikes=totalTest))
    return(output)
  }

  shifted <- lagList(stRef,stTest,laglim)
  result <- list(shiftedT=shifted[-length(shifted)],
                 nbRefSpikes=length(shifted)-1,
                 nbTestSpikes=shifted[[length(shifted)]],
                 laglim=laglim,
                 acquisitionWindow=acquisitionWindow,
                 obsTime=(diff(acquisitionWindow)-diff(laglim))*nbRepeat,
                 call=match.call()
                 )
  class(result) <- "lockedTrain"
  return(result)

}

print.lockedTrain <- function(x,...) plot(x)

plot.lockedTrain <- function(x,
                             keepTime=FALSE,
                             stimTimeCourse=NULL,
                             colStim="grey80",
                             xlim,
                             pch,
                             xlab,
                             ylab,
                             main,
                             ...
                             ) {

  ## if stimTimeCourse is not NULL it should be a vector with 2 elements
  if (!is.null(stimTimeCourse)) {
    if (length(stimTimeCourse) != 2)
      stop(paste(deparse(substitute(stimTimeCourse)),
                 "should be a vector with 2 elements.")
           )
  } ## End of conditional on !is.null(stimTimeCourse)

  if (missing(xlab)) xlab <- "Lag (s)"

  nameRef <- deparse(x$call[["stRef"]])
  if (missing(ylab)) {
    if (keepTime) {
      ylab <- paste("Time of",
                    nameRef,
                    "spikes (s)")
    } else {
      ylab <- paste("Index of",
                    nameRef,
                    "spikes")
    }
  }

  if (missing(main)) {
    if (!is.null(x$call[["stTest"]])) {
      nameTest <- deparse(x$call[["stTest"]])
      main <- paste("Cross raster plot of",
                    nameRef,
                    "and",
                    nameTest
                    )
    } else {
      main <- paste("Cross raster plot of",
                    nameRef,
                    "with itself."
                    )
    } ## End of conditional on !is.null(x$call[["stTest"]])
  } ## End of conditional on missing(main)

  nbRefSpikes <- x$nbRefSpikes
  allT <- unlist(lapply(x$shiftedT, function(l) l$refTime))
  yIdx <- sort.int(allT,index.return=TRUE)$ix
  lastRefSpike <- max(allT)
  laglim <- x$laglim
  if (missing(xlim)) xlim <- laglim
  if (missing(pch)) pch <- "*"
  
  plot(laglim,
       if (keepTime) {c(0,lastRefSpike)} else {c(1,nbRefSpikes+1)},
       type="n",
       xlab=xlab,
       ylab=ylab,
       xlim=xlim,
       ylim=if (keepTime) {c(0,lastRefSpike)} else {c(1,nbRefSpikes+1)},
       bty="n",
       main=main
       )

  sortedRefSpikes <- allT[yIdx]
  if (keepTime) {
    if (!is.null(stimTimeCourse))
      rect(laglim[1],stimTimeCourse[1],
           laglim[2],stimTimeCourse[2],
           col="gray80",
           lty=0)
         
    Y <- sortedRefSpikes
  } else {
    if (!is.null(stimTimeCourse)) {
      goodOnes <- stimTimeCourse[1] <= sortedRefSpikes &
      sortedRefSpikes <= stimTimeCourse[2]
      rect(laglim[1],min((1:nbRefSpikes)[goodOnes]),
           laglim[2],max((1:nbRefSpikes)[goodOnes]),
           col="gray80",
           lty=0)
    }
    Y <- 1:nbRefSpikes
  }

  abline(v=0,col="gray30",lty=2)
  
  invisible(sapply(yIdx,
                   function(idx) {
                     xx <- x$shiftedT[[idx]]$crossTime
                     yy <- numeric(length(xx)) + Y[idx]
                     points(xx,yy,pch=pch)
                   }
                   )
            )
  
}




#'Auto- and Cross-Intensity Function Estimate for Spike Trains
#'
#'\code{hist.lockedTrain} constructs and \code{plot.hist.lockedTrain} plots
#'estimates of what Cox and Lewis (1966) call the auto- or cross-intensity
#'functions. The auto-intensity function is also called the renewal density by
#'Cox and Lewis and by Perkel et al (1967) while it is called the intensity of
#'the Palm distribution by Ogata (1988). The (estimate of) the cross-intensity
#'function is called cross-correlation function by Perkel et al (1967b) and
#'cross-correlation histogram by Brillinger et al (1976).
#'
#'The intensity of the Palm distribution (Ogata, 1988, p 13) is estimated by:
#'\deqn{\mathrm{m}(s) = \frac{\mathrm{Prob}(\mathrm{event \, in} }{m(s) =
#'Prob(event in (t+s,t+s+bw) | event at t) / bw}\deqn{ \, (t+s,t+s+\Delta s) \,
#'\mid \, \mathrm{event \, at} \, t)}{\Delta }{m(s) = Prob(event in
#'(t+s,t+s+bw) | event at t) / bw}\deqn{ s}}{m(s) = Prob(event in (t+s,t+s+bw)
#'| event at t) / bw} It is called \emph{renewal density} by Perkel et al
#'(1967) and defined by their Eq. 10, p 404.  Under the null hypothesis of a
#'stationary Poisson process it is a constant whose value is the mean discharge
#'rate.
#'
#'The cross-intensity function of two spike trains A and B is estimated by
#'(Perkel et al, 1967b, p424, Eq. 4 and 5): \deqn{\mathrm{m}_{AB}(s) =
#'\frac{\mathrm{Prob}(\mathrm{B \, event \, in} }{m(s;AB) = Prob(B event in
#'(t+s,t+s+bw) | A event at t) / bw}\deqn{ \, (t+s,t+s+\Delta s) \, \mid \,
#'\mathrm{A \, event \, at} \, t)}{\Delta }{m(s;AB) = Prob(B event in
#'(t+s,t+s+bw) | A event at t) / bw}\deqn{ s}}{m(s;AB) = Prob(B event in
#'(t+s,t+s+bw) | A event at t) / bw}
#'
#'The \code{style} argument of \code{plot.hist.lockedTrain} generates a plot
#'looking like Fig. 6, p 18 of Ogata (1988) if set to \code{"Ogata"}. Using
#'\code{style} \code{"Brillinger"} plots the square root of the estimate.
#'
#'@aliases plot.hist.lockedTrain hist.lockedTrain
#'@param x a \code{lockedTrain} object returned by the
#'\code{\link{lockedTrain}} function.
#'@param bw a non-negative numeric, the bin width.
#'@param breaks a vector giving the breakpoints between cells. If \code{NULL}
#'(default) breaks are built using argument \code{bw} and component
#'\code{laglim} of \code{obj}.
#'@param plot a logical. If \code{TRUE} a plot is generated as a side effect
#'and nothing is returned, if \code{FALSE} a list of class
#'\code{hist.lockedTime} is returned.
#'@param style a character. The style of the plot, \code{"Ogata"} or
#'\code{"Brillinger"}.
#'@param CI a numeric vector with at most two elements. The coverage
#'probability of the confidence intervals.
#'@param unit a character. The unit in which the spike times are expressed.
#'@param xlab a character. The x label. Default supplied.
#'@param ylab a character. The y label. Default supplied.
#'@param xlim a numeric. See \code{\link{plot}}. Default supplied.
#'@param ylim a numeric. See \code{\link{plot}}. Default supplied.
#'@param type see \code{\link{lines}}. Default supplied.
#'@param pch see \code{\link{plot}}. Default supplied.
#'@param \dots see \code{\link{plot}}.
#'@return When argument \code{plot} in \code{hist.lockedTrain} is set to
#'\code{FALSE} a list of class \code{hist.lockedTrain} with the following
#'components is returned:
#'@returnItem density the density estimate. Equivalent of the component
#'\code{density} returned by \code{\link{hist}}.
#'@returnItem breaks a numeric vector with the breaks in between which spikes
#'were counted. Similar to the component of the same name returned by
#'\code{\link{hist}}.
#'@returnItem mids a numeric vector with the mid points of \code{breaks}. .
#'Similar to the component of the same name returned by \code{\link{hist}}.
#'@returnItem bw the bin width used.
#'@returnItem nRef the total number of reference spikes used.
#'@returnItem refFreq the mean frequency of the reference neuron.
#'@returnItem testFreq the mean frequency of the test neuron.
#'@returnItem obsTime the total observation time used (in s).
#'@returnItem CCH a logical which is \code{TRUE} if a cross-intensity was
#'estimated and \code{FALSE} in the case of an auto-intensity.
#'@returnItem call the matched call.
#'@note The confidence intervals are obtained from a Poisson distribution with
#'parameter: \code{refFreq} * \code{testFreq} * \code{bw} * \code{obsTime}.
#'Once the quantiles of the Poisson distribution have been obtained they are
#'divided by: \code{refFreq} * \code{bw} * \code{obsTime}
#'
#'These intervals are valid under the stationary Poisson null hypothesis for
#'the auto-intensity estimates. They are valid under the \emph{stationary
#'independent} null hypothesis for the cross-intensity. \emph{There is NO NEED
#'to assume that the test train is Poisson or renewal.} See Perkel et al
#'(1967b) and McFadden (1962) for a justification/proof of that. The square
#'root transform of Brillinger (1976) and Brillinger et al (1976) is (in my
#'opinion) a perfect example of shooting at a sparrow with a bazooka. An
#'oversized method to get at an intuitively obvious result. There is moreover
#'no need to stabilize the variance if your testing against a Poisson with a
#'constant rate since then the variance of the null hypothesis is stable to
#'start with. These (square root) transforms are useful for least square fits
#'with a Poisson noise but NOT in the present context.
#'@author Christophe Pouzat \email{christophe.pouzat@@gmail.com}
#'@seealso \code{\link{varianceTime}}, \code{\link{renewalTestPlot}},
#'\code{\link{lockedTrain}}
#'@references Ogata, Yosihiko (1988) Statistical Models for Earthquake
#'Occurrences and Residual Analysis for Point Processes. \emph{Journal of the
#'American Statistical Association} \bold{83}: 9-27.
#'
#'D. R. Cox and P. A. W. Lewis (1966) \emph{The Statistical Analysis of Series
#'of Events}. John Wiley and Sons.
#'
#'J. A. McFadden (1962) On the Lengths of Intervals in a Stationary Point
#'Process. \emph{Journal of the Royal Statistical Society. Series B},
#'\bold{24}: 364-382
#'
#'Perkel D. H., Gerstein, G. L. and Moore G. P. (1967) Neural Spike Trains and
#'Stochastic Point Processes. I. The Single Spike Train. \emph{Biophys. J.},
#'\bold{7}: 391-418.
#'\url{http://www.pubmedcentral.nih.gov/articlerender.fcgi?tool=pubmed&pubmedid=4292791}
#'
#'Perkel D. H., Gerstein, G. L. and Moore G. P. (1967b) Neural Spike Trains and
#'Stochastic Point Processes. I. Simultaneous Spike Trains. \emph{Biophys. J.},
#'\bold{7}: 419-440.
#'\url{http://www.pubmedcentral.nih.gov/articlerender.fcgi?tool=pubmed&pubmedid=4292792}
#'
#'David R. Brillinger, Hugh L. Bryant and Jose P. Segundo (1976) Identification
#'of synaptic interactions. \emph{Biol Cybern}, \bold{22}: 213-228.
#'
#'David R. Brillinger (1976) Estimation of the Second-Order Intensities of a
#'Bivariate Stationary Point Process. \emph{Journal of the Royal Statistical
#'Society. Series B (Methodological)}, \bold{38}, 60-66.
#'@keywords ts survival
#'@examples
#'
#'## Reproduce Fig. 6 of Ogata 1988
#'data(ShallowShocks)
#'shalShocks <- lockedTrain(as.spikeTrain(ShallowShocks$Date),,c(0,500))
#'shalShocksH <- hist(shalShocks,5,plot=FALSE)
#'plot(shalShocksH,"Ogata",c(0.95,0.99),xlab="TIME LAG (DAYS)",ylab="NUMBER OF EVENTS PER DAY")
#'## Reproduce Fig. 7 of Ogata 1988
#'myBinNb <- 101
#'myMidPoints <- seq(from = 1, to = 6, length.out=myBinNb)
#'myMidPoints <- 10^myMidPoints/200
#'myBreaks <- c(0,myMidPoints[-myBinNb] + diff(myMidPoints) / 2)
#'shalShocksH2 <- hist(shalShocks,breaks=myBreaks,plot=FALSE)
#'yy <- abs(shalShocksH2$density - shalShocksH2$refFreq)
#'plot(shalShocksH2$mids[shalShocksH2$density>0],
#'     yy[shalShocksH2$density>0],
#'     pch = 1,
#'     xlim = c(0.001,10000),
#'     log = "xy",
#'     xlab = "TIME LAG (DAYS)",
#'     ylab = "NUMBER OF EVENTS PER DAY"
#'     )
#'
#'
hist.lockedTrain <- function(x,
                             bw,
                             breaks=NULL,
                             plot=TRUE,
                             ...
                             ) {
  
  if (missing(bw)) {
    testISI <- unlist(lapply(x$shiftedT,
                             function(l) {
                               testT <- l$crossTime
                               c(diff(testT[testT<0]),
                                 diff(testT[testT>0]))
                             }
                             )
                      )
    bw <- sd(testISI)/5
  }
  
  laglim <- x$laglim
  nbRefSpikes <- x$nbRefSpikes
  allT <- unlist(lapply(x$shiftedT, function(l) l$crossTime))
  if (is.null(breaks)) {
    if (laglim[1] < 0) {
      ##l <- ((laglim[1]+bw/2)%/%bw)*bw-bw/2
      l <- laglim[1]
      ##r <- ((laglim[2]-bw/2)%/%bw)*bw+bw/2
      r <- laglim[2]
    } else {
      l <- 0
      ##r <- (laglim[2] %/% bw)*bw
      r <- laglim[2]
    }
    breaks <- seq(l,r,by=bw)
  } 
  l <- min(breaks)
  r <- max(breaks)
 
  
  allT <- allT[l < allT & allT < r]
  myHist <- hist(allT,breaks=breaks,plot=FALSE)

  nRef <- nbRefSpikes
  refFreq <- nbRefSpikes/x$obsTime
  testFreq <- x$nbTestSpikes/x$obsTime
  
  density <- myHist$counts/nRef/diff(breaks)
  if (!is.null(x$call[["stTest"]])) CCH <- TRUE
  else CCH <- FALSE

  result <- list(density=density,
                 breaks=myHist$breaks,
                 mids=myHist$mids,
                 bw=bw,
                 nRef=nRef,
                 refFreq=refFreq,
                 testFreq=testFreq,
                 obsTime=x$obsTime,
                 CCH=CCH,
                 call=match.call()
                 )
  class(result) <- "hist.lockedTrain"
  
  if (!plot) return(result)
  else plot(result,...)
  
}

plot.hist.lockedTrain <- function(x,
                                  style=c("Ogata","Brillinger"),
                                  CI,
                                  unit="s",
                                  xlab,
                                  ylab,
                                  xlim,
                                  ylim,
                                  type,
                                  pch,
                                  ...) {

  ## check CI
  ## make sure that CI is at most of length 2 otherwise
  ## keep the first 2 components
  if (missing(CI)) CI <- 0.95
  if (length(CI) > 2) CI <- CI[1:2]
  ## Check that each component of CI is between 0 and 1
  if (any(CI>=1 | CI<=0))
    stop(paste(deparse(substitute(CI)),
               "components should be in (0,1)")
         )
  bw <- x$bw
  refFreq <- x$refFreq
  testFreq <- x$testFreq
  obsTime <- x$obsTime
  lambda <- refFreq*testFreq*bw*obsTime
  lwr <- sapply(CI, function(ci) qpois((1-ci)/2,lambda))
  upr <- sapply(CI, function(ci) qpois(1-(1-ci)/2,lambda))
  lwr <- lwr/bw/obsTime/refFreq
  upr <- upr/bw/obsTime/refFreq
  if (missing(xlab)) xlab <- paste("Time Lag (",unit,")",sep="")
  if (missing(xlim)) xlim <- range(x$breaks)
  if (missing(type)) type <- "o"
  if (missing(pch)) pch <- 8
  xx <- x$mids
  CCH <- x$CCH

  if (style[1] == "Ogata") {
    yy <- x$density
    if (missing(ylab) && CCH) ylab <- "CCH"
    if (missing(ylab) && !CCH) ylab <- "ACH"
    if (missing(ylim)) {
      ylim <- c(0.9*min(c(yy,lwr)),max(c(yy,upr))*1.1)
    }

    plot(xx,
         yy,
         type="n",
         xlab=xlab,
         ylab=ylab,
         xlim=xlim,
         ylim=ylim,
         xaxs="i",
         yaxs="i")
    sapply(lwr, function(l) abline(h=l,lty=2))
    sapply(upr, function(u) abline(h=u,lty=2))       
    abline(h=testFreq)
    abline(v=0)
    lines(xx,
          yy,
          type=type,
          pch=pch,
          ...)
  } else {
    yy <- sqrt(x$density)
    if (missing(ylab) && CCH) ylab <- expression(sqrt(CCH))
    if (missing(ylab) && !CCH) ylab <- expression(sqrt(ACH))
    lwr <- sapply(lwr, function(ci) sqrt(ci))
    upr <- sapply(upr, function(ci) sqrt(ci))
    
    if (missing(ylim)) {
      ylim <- c(0,max(c(max(upr),max(yy)))*1.01)
    }

    plot(xx,
         yy,
         type="n",
         xlab=xlab,
         ylab=ylab,
         xlim=xlim,
         ylim=ylim,
         xaxs="i",
         yaxs="i")
    sapply(lwr, function(l) abline(h=l,lty=2))
    sapply(upr, function(u) abline(h=u,lty=2))       
    abline(h=sqrt(testFreq))
    lines(xx,
          yy,
          type=type,
          pch=pch,
          ...)
    
  } ## End of conditional on style
  
}

