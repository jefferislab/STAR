#'Smooth Peri Stimulus Time Histogram Related Functions and Methods: The
#'Penalized Regression Spline Approach
#'
#'Function \code{gampsth} computes a smooth psth, while method
#'\code{print.gampsth} prints and \code{summary.gampsth} summarises the
#'\code{gamObject} contained in the returned \code{gampsth} object and
#'\code{plot.gampsth} plots it.
#'
#'For \code{gampsth}, the raw data contained in \code{repeatedTrain} are
#'pre-processed with \code{\link{hist}} using a bin size given by argument
#'\code{binSize}. This \code{binSize} should be small "enough". That is, the
#'rate of the aggregated train created by collapsing the spike times of the
#'different trials onto a single "pseudo" spike train, should not change too
#'much on the scale of \code{binSize} (see Ventura et al (2002) Sec. 4.2 p8 for
#'more details).
#'
#'@aliases gampsth print.gampsth summary.gampsth plot.gampsth
#'@param repeatedTrain a \code{repeatedTrain} object or a list which can be
#'coerced to such an object.
#'@param binSize the bin size (in s) used to generate the observations on which
#'the gam fit will be performed. See details below.
#'@param k the dimension of the basis used to represent the smooth psth. See
#'\code{\link[mgcv]{s}}.
#'@param bs the type of splines used. See \code{\link[mgcv]{s}}.
#'@param plot corresponding argument of \code{\link{hist}}. Should a plot be
#'generated or not?
#'@param object a \code{gampsth} object.
#'@param x a \code{gampsth} object.
#'@param stimTimeCourse \code{NULL} (default) or a two elements vector
#'specifying the time boundaries (in s) of a stimulus presentation.
#'@param colStim the background color used for the stimulus.
#'@param colCI if not \code{NULL} (default) a confidence band is plotted with
#'the specified color; two dashed lines are plotted otherwise.
#'@param xlim a numeric (default value supplied). See \code{\link{plot}}.
#'@param ylim a numeric (default value supplied). See \code{\link{plot}}.
#'@param xlab a character (default value supplied). See \code{\link{plot}}.
#'@param ylab a character (default value supplied). See \code{\link{plot}}.
#'@param main a character (default value supplied). See \code{\link{plot}}.
#'@param lwd line width used to plot the estimated density. See
#'\code{\link{plot}}.
#'@param col color used to plot the estimated density. See \code{\link{plot}}.
#'@param \dots in \code{gampsth}, if \code{plot} is set to \code{TRUE} then the
#'\dots{} are passed to \code{plot.gampsth}. In \code{plot.gampsth} they are
#'passed to \code{\link{plot}} which is called internally. They are not used
#'otherwise.
#'@return When \code{plot} is set to \code{FALSE} in \code{gampsth}, a list of
#'class \code{gampsth} is returned and no plot is generated. This list has the
#'following components:
#'
#'When \code{plot} is set to \code{TRUE} nothing is returned and a plot is
#'generated as a side effect. Of course the same occurs upon calling
#'\code{plot.gampsth} with a \code{gampsth} object argument.
#'
#'\code{print.gampsth} returns the result of \code{\link[mgcv]{print.gam}}
#'applied to the \code{\link[mgcv]{gamObject}} generated by \code{gampsth} and
#'stored in the \code{\link{environment}} of both \code{lambdaFct} and
#'\code{LambdaFct}.
#'
#'\code{summary.gampsth} returns the result of \code{\link[mgcv]{summary.gam}}
#'applied to the \code{\link[mgcv]{gamObject}} generated by \code{gampsth} and
#'stored in the \code{\link{environment}} of both \code{lambdaFct} and
#'\code{LambdaFct}.
#'@returnItem freq a vector containing the instantaneous firing rate in the
#'middle of the "thin" bins used for preprocessing.
#'@returnItem ciUp a vector with the upper limit of a pointwise 95\% confidence
#'interval. Check \code{\link[mgcv]{predict.gam}} for details.
#'@returnItem ciLow a vector with the lower limit of a pointwise 95\%
#'confidence interval.
#'@returnItem breaks a vector with 2 elements the ealiest and the latest spike
#'in \code{repeatedTrain}.
#'@returnItem mids a numeric vector with the mid points of the bins.
#'@returnItem counts a vector with the actual number of spikes in each bin.
#'@returnItem nbTrials the number of trials in \code{repeatedTrain}.
#'@returnItem lambdaFct a function of a single time argument returning the
#'estimated intensity (or instantaneous rate) at its argument.
#'@returnItem LambdaFct a function of a single time argument returning the
#'integrale of estimated intensity (or instantaneous rate) at its argument.
#'That is, the integrated intensity. \code{\link{integrate}} is used by this
#'function.
#'@returnItem call the matched call.
#'@note Most of the components of the list returned by \code{gampsth} are not
#'of direct interest for the user but they are used by, for instance,
#'\code{\link{reportHTML.repeatedTrain}}.
#'@author Christophe Pouzat \email{christophe.pouzat@@gmail.com}
#'@seealso \code{\link{psth}}, \code{\link{plot.psth}},
#'\code{\link[mgcv]{gam}}, \code{\link[mgcv]{print.gam}},
#'\code{\link[mgcv]{summary.gam}}, \code{\link[mgcv]{gam.check}},
#'\code{\link{reportHTML.repeatedTrain}},
#'@references Ventura, V., Carta, R., Kass, R. E., Gettner, S. N. and Olson, C.
#'R. (2002) Statistical analysis of temporal evolution in single-neuron firing
#'rates. \emph{Biostatistics} \bold{3}: 1--20.
#'
#'Kass, R. E., Ventura, V. and Cai, C. (2003) Statistical smoothing of neuronal
#'data. \emph{Network: Computation in Neural Systems} \bold{14}: 5--15.
#'
#'Wood S.N. (2006) \emph{Generalized Additive Models: An Introduction with R}.
#'Chapman and Hall/CRC Press.
#'@keywords models smooth regression
#'@examples
#'
#'\dontrun{
#'## Get the e070528citronellal data set into workspace
#'data(e070528citronellal)
#'## Compute gampsth without a plot for neuron 1
#'## using a cubic regression spline
#'n1CitrGAMPSTH <- gampsth(e070528citronellal[[1]],plot=FALSE,bs="cr")
#'## plot the result
#'plot(n1CitrGAMPSTH,stim=c(6.14,6.64),colCI=2)
#'## get a summary of the gam fit
#'summary(n1CitrGAMPSTH)
#'## perhaps get a more complete check wit gam.check
#'n1CitrGAMPSTHgo <- gamObj(n1CitrGAMPSTH)
#'gam.check(n1CitrGAMPSTHgo)
#'## It does not look too bad
#'## Now take a look at the observation on which the gam
#'## was actually performed
#'plot(n1CitrGAMPSTH$mids,n1CitrGAMPSTH$counts,type="l")
#'## put dots at the positions of the knots
#'X <- n1CitrGAMPSTHgo$smooth[[1]][["xp"]]
#'rug(X,col=2)
#'## Add the estimated smooth psth after proper scaling
#'theBS <- diff(n1CitrGAMPSTH[["mids"]])[1]
#'Y <- n1CitrGAMPSTH$lambdaFct(n1CitrGAMPSTH$mids)*theBS*n1CitrGAMPSTH$nbTrials
#'lines(n1CitrGAMPSTH$mids,Y,col=4,lwd=2)
#'}
gampsth <- function (repeatedTrain,
                     binSize=0.025,
                     k=100,
                     bs="tp",
                     plot=TRUE,
                     ...) {
  
  if (!is.repeatedTrain(repeatedTrain)) 
    repeatedTrain <- as.repeatedTrain(repeatedTrain)

  bigTrain <- sort(unlist(repeatedTrain))
  minSpikeTime <- floor(min(bigTrain))
  maxSpikeTime <- ceiling(max(bigTrain))
  Time <- seq(minSpikeTime,maxSpikeTime,by=binSize)
  if (max(bigTrain) > max(Time)) Time <- c(Time,max(Time)+binSize)
  H <- hist(bigTrain,breaks=Time,plot=FALSE)
  Count <- H$counts
  Time <- H$mids

  PoissonF <- gam(Count ~ s(Time,k=k,bs=bs),family=poisson)
  nbTrials <- length(repeatedTrain)

  Y <- predict(PoissonF,type="response",se.fit=TRUE)
  Y$fit <- Y$fit/nbTrials/binSize
  Y$se.fit <- Y$se.fit/nbTrials/binSize

  ## create a function returning the intensity
  lambdaFct <- function(t) {
    as.numeric(predict(PoissonF,
                       newdata=data.frame(Time=t),
                       type="response")/nbTrials/binSize
               )
  }

  ## create a function returning the integrated intensity
  LambdaFct <- function(t) {
    t <- sort(t)
    t <- t[minSpikeTime <= t & t <= maxSpikeTime]
    tL <- length(t)
    result <- numeric(tL)
    result[1] <- integrate(lambdaFct,minSpikeTime,t[1])$value
    if (tL > 1) for (i in 2:tL) result[i] <- integrate(lambdaFct,t[i-1],t[i])$value
    cumsum(result)
  }

  result <- list(freq=Y$fit,
                 ciUp=Y$fit+1.96*Y$se.fit,
                 ciLow=Y$fit-1.96*Y$se.fit,
                 breaks=c(minSpikeTime,maxSpikeTime), 
                 mids=Time,
                 counts=Count,
                 nbTrials=nbTrials,
                 lambdaFct=lambdaFct,
                 LambdaFct=LambdaFct,
                 call=match.call())
  class(result) <- "gampsth"
    
  if (plot) {
    plot(result, ...)
  }
  else {
    return(result)
  }
  
}


summary.gampsth <- function(object, ...) {
  summary(gamObj(object))
}

print.gampsth <- function(x, ...) {
  print(gamObj(x))
}


plot.gampsth <- function (x,
                        stimTimeCourse=NULL,
                        colStim="grey80",
                        colCI=NULL, 
                        xlab, ylab, main, xlim, ylim,
                        lwd=2, col=1,
                        ...) {
  
    if (!is.null(stimTimeCourse)) {
      if (length(stimTimeCourse) != 2) 
        stop(paste(deparse(substitute(stimTimeCourse)),
                   "should be a vector with 2 elements.")
             )
    }
    if (missing(xlab)) 
      xlab <- "Time (s)"
    if (missing(ylab)) 
      ylab <- "Freq (Hz)"
    if (missing(main)) {
      nameList <- deparse(x$call[["repeatedTrain"]])
      main <- paste(nameList, "PSTH")
    }
    
    withCI <- TRUE
    smoothOne <- TRUE
    if (missing(xlim)) xlim <- x$breaks
    if (missing(ylim)) ylim <- c(0, max(x$ciUp))

    ## Generate the frame of the plot with "decorations"
    plot(xlim, ylim, type = "n", xlab = xlab, ylab = ylab, main = main, 
         xlim = xlim, ylim = ylim, ...)

    ## if a stim time course is given make it appear
    if (!is.null(stimTimeCourse)) {
      rect(stimTimeCourse[1], 0, stimTimeCourse[2], ylim[2], 
           col = colStim, lty = 0)
    }

    ## Add confidence bands
    if (is.null(colCI)) {
      lines(x$mids, x$ciLow, lty = 2)
      lines(x$mids, x$ciUp, lty = 2)
    } else {
      polygon(c(x$mids, rev(x$mids)), c(x$ciLow, rev(x$ciUp)), 
              col = colCI, border = NA)
    }
    
    lines(x$mids, x$freq, col = col, lwd = lwd)
    
    abline(h = 0)
}
